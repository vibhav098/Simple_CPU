/**
 * This is an autogenerated netlist code from CircuitVerse. Verilog Code can be
 * tested on https://www.edaplayground.com/ using Icarus Verilog 0.9.7. This is an
 * experimental module and some manual changes make need to be done in order for
 * this to work.
 *
 * If you have any ideas/suggestions or bug fixes, raise an issue
 * on https://github.com/CircuitVerse/CircuitVerse/issues/new/choose
 */

/*
  Element Usage Report
    Input - 49 times
    Splitter - 31 times
    DflipFlop - 20 times
    TriState - 21 times
    Output - 60 times
    AndGate - 6 times
    OrGate - 4 times
    XorGate - 5 times
    SubCircuit - 30 times
    NorGate - 1 times
    Clock - 2 times
    NotGate - 5 times
    DigitalLed - 4 times
    Decoder - 2 times
    ConstantVal - 11 times
    Ground - 4 times
    Multiplexer - 3 times
    PriorityEncoder - 1 times
    EEPROM - 2 times
    HexDisplay - 18 times
*/

/*
  Usage Instructions and Tips
    Labels - Ensure unique label names and avoid using verilog keywords
    Warnings - Connect all optional inputs to remove warnings
    Clock - Use a single global clock
*/

// Sample Testbench Code - Uncomment to use

/*
module TestBench();

  reg inp_0, clk_0, REG_IN, CLK;
  reg [7:0] inp_2;

  wire [2:0] out_8;
  wire [3:0] out_7, MAR_ADD;
  wire [7:0] out_0, out_1, out_2, out_3, out_4, out_5, out_6;

  BUS_OUTLAY DUT0(out_0, out_1, out_2, out_3, out_4, out_5, out_6, out_7, out_8, clk_0, inp_0);

  MAR DUT1(MAR_ADD, REG_IN, CLK, inp_2);

  always begin
    #10
    clk_0 = 0;
    #10
    clk_0 = 1;
  end

  initial begin
    inp_0 = 0;
    REG_IN = 0;
    CLK = 0;
    inp_2 = 0;

    #15
    $display("out_0 = %b", out_0);
    $display("out_1 = %b", out_1);
    $display("out_2 = %b", out_2);
    $display("out_3 = %b", out_3);
    $display("out_4 = %b", out_4);
    $display("out_5 = %b", out_5);
    $display("out_6 = %b", out_6);
    $display("out_7 = %b", out_7);
    $display("out_8 = %b", out_8);
    $display("MAR_ADD = %b", MAR_ADD);

    #10
    $display("out_0 = %b", out_0);
    $display("out_1 = %b", out_1);
    $display("out_2 = %b", out_2);
    $display("out_3 = %b", out_3);
    $display("out_4 = %b", out_4);
    $display("out_5 = %b", out_5);
    $display("out_6 = %b", out_6);
    $display("out_7 = %b", out_7);
    $display("out_8 = %b", out_8);
    $display("MAR_ADD = %b", MAR_ADD);

    $finish;

  end
endmodule

*/

module Bi_genreg(DISP, CLK, REG_OUT, REG_IN, DATA);
  output [7:0] DISP;
  input CLK, REG_OUT, REG_IN;
  input [7:0] DATA;
  wire DflipFlop_7_Q, TriState_0_out, DflipFlop_6_Q, DflipFlop_5_Q, DflipFlop_4_Q, DflipFlop_3_Q, DflipFlop_2_Q, DflipFlop_1_Q, DflipFlop_0_Q;
  wire [7:0] Splitter_2_cmb;
  
  DflipFlop DflipFlop_7(DflipFlop_7_Q, , CLK, DATA[7], , , REG_IN);
  assign DATA[7] = (REG_OUT!=0) ? DflipFlop_7_Q : 1'b?;
  
  assign Splitter_2_cmb = {DflipFlop_7_Q,DflipFlop_6_Q,DflipFlop_5_Q,DflipFlop_4_Q,DflipFlop_3_Q,DflipFlop_2_Q,DflipFlop_1_Q,DflipFlop_0_Q};
  assign DISP = Splitter_2_cmb;
  DflipFlop DflipFlop_6(DflipFlop_6_Q, , CLK, DATA[6], , , REG_IN);
  assign DATA[6] = (REG_OUT!=0) ? DflipFlop_6_Q : 1'b?;
  DflipFlop DflipFlop_5(DflipFlop_5_Q, , CLK, DATA[5], , , REG_IN);
  assign DATA[5] = (REG_OUT!=0) ? DflipFlop_5_Q : 1'b?;
  DflipFlop DflipFlop_4(DflipFlop_4_Q, , CLK, DATA[4], , , REG_IN);
  assign DATA[4] = (REG_OUT!=0) ? DflipFlop_4_Q : 1'b?;
  DflipFlop DflipFlop_3(DflipFlop_3_Q, , CLK, DATA[3], , , REG_IN);
  assign DATA[3] = (REG_OUT!=0) ? DflipFlop_3_Q : 1'b?;
  DflipFlop DflipFlop_2(DflipFlop_2_Q, , CLK, DATA[2], , , REG_IN);
  assign DATA[2] = (REG_OUT!=0) ? DflipFlop_2_Q : 1'b?;
  DflipFlop DflipFlop_1(DflipFlop_1_Q, , CLK, DATA[1], , , REG_IN);
  assign DATA[1] = (REG_OUT!=0) ? DflipFlop_1_Q : 1'b?;
  DflipFlop DflipFlop_0(DflipFlop_0_Q, , CLK, DATA[0], , , REG_IN);
  assign DATA[0] = (REG_OUT!=0) ? DflipFlop_0_Q : 1'b?;
endmodule

module adder(S, C_out, A, B, C_in);
  output S,  C_out;
  input A, B, C_in;
  wire and_0_out, or_1_out, xor_0_out, or_0_out, and_1_out;
  assign and_0_out = C_in & or_0_out;
  assign or_1_out = and_0_out | and_1_out;
  assign C_out = or_1_out;
  assign xor_0_out = A ^ B ^ C_in;
  assign S = xor_0_out;
  assign or_0_out = A | B;
  assign and_1_out = A & B;
endmodule


module full_adder(C_out, S, IN_1, IN_2, C_in);
  output C_out;
  output [7:0] S;
  input C_in;
  input [7:0] IN_1, IN_2;
  wire \0_out_0 , \0_out_1 , \1_out_0 , \1_out_1 , \2_out_0 , \2_out_1 , \3_out_0 , \3_out_1 , \4_out_0 , \4_out_1 , \5_out_0 , \5_out_1 , \6_out_0 , \6_out_1 , \7_out_0 , \7_out_1 ;
  wire [7:0] Splitter_2_cmb;
  adder \0 (\0_out_0 , \0_out_1 , IN_1[0], IN_2[0], C_in);
  adder \1 (\1_out_0 , \1_out_1 , IN_1[1], IN_2[1], \0_out_1 );
  adder \2 (\2_out_0 , \2_out_1 , IN_1[2], IN_2[2], \1_out_1 );
  adder \3 (\3_out_0 , \3_out_1 , IN_1[3], IN_2[3], \2_out_1 );
  adder \4 (\4_out_0 , \4_out_1 , IN_1[4], IN_2[4], \3_out_1 );
  adder \5 (\5_out_0 , \5_out_1 , IN_1[5], IN_2[5], \4_out_1 );
  adder \6 (\6_out_0 , \6_out_1 , IN_1[6], IN_2[6], \5_out_1 );
  adder \7 (\7_out_0 , \7_out_1 , IN_1[7], IN_2[7], \6_out_1 );
  assign C_out = \7_out_1 ;
  assign Splitter_2_cmb = {\7_out_0 ,\6_out_0 ,\5_out_0 ,\4_out_0 ,\3_out_0 ,\2_out_0 ,\1_out_0 ,\0_out_0 };
  assign S = Splitter_2_cmb;
  
  
endmodule

module zero(OUT, IN);
  output OUT;
  input [7:0] IN;
  wire nor_0_out;
  
  assign nor_0_out = ~(IN[3] | IN[2] | IN[1] | IN[0] | IN[4] | IN[5] | IN[6] | IN[7]);
  assign OUT = nor_0_out;
endmodule





module gajendraAlu(OUTPUT, DISP, status_reg, clk_0, A, B, ALU_OP, ALU_OUT);
  output [3:0] status_reg;
  output [7:0] OUTPUT, DISP;
  input ALU_OUT, clk_0;
  input [2:0] ALU_OP;
  input [7:0] A, B;
  wire full_adder_4_out_0, zero_3_out, not_1_out, full_adder_2_out_0, not_2_out, Decoder_0_out_0, Decoder_0_out_1, Decoder_0_out_2, Decoder_0_out_3, Decoder_0_out_4, Decoder_0_out_5, Decoder_0_out_6, const_4, const_3, const_2, const_1, const_0, Ground_0_out;
  wire [3:0] Splitter_0_cmb;
  wire [7:0] B_out, not_3_out, full_adder_4_out_1, TriState_5_out, TriState_4_out, and_0_out, xor_0_out, full_adder_2_out_1, A_out, Splitter_4_cmb, Splitter_2_cmb, not_0_out;
  Bi_genreg B(B_out, clk_0, const_2, const_3, B);
  assign not_3_out = ~B_out;
  full_adder full_adder_4(full_adder_4_out_0, full_adder_4_out_1, not_3_out, A_out, Decoder_0_out_4);
  assign TriState_5_out = (Decoder_0_out_4!=0) ? full_adder_4_out_1 : 8'b?;
  assign TriState_4_out = (ALU_OUT!=0) ? TriState_5_out : 8'b?;
  assign OUTPUT = TriState_4_out;
  zero zero_3(zero_3_out, TriState_5_out);
  assign not_1_out = ~zero_3_out;
  assign Splitter_0_cmb = {not_1_out,zero_3_out,not_2_out,full_adder_2_out_0};
  assign status_reg = Splitter_0_cmb;
  
      always @ (*)
        $display("DigitalLed:NZ=%d", not_1_out);
  
      always @ (*)
        $display("DigitalLed:Z=%d", zero_3_out);
  assign DISP = TriState_5_out;
  assign and_0_out = A_out & B_out;
  assign TriState_5_out = (Decoder_0_out_2!=0) ? and_0_out : 8'b?;
  assign xor_0_out = A_out ^ B_out;
  assign TriState_5_out = (Decoder_0_out_1!=0) ? xor_0_out : 8'b?;
  full_adder full_adder_2(full_adder_2_out_0, full_adder_2_out_1, B_out, A_out, );
  assign TriState_5_out = (Decoder_0_out_0!=0) ? full_adder_2_out_1 : 8'b?;
  assign not_2_out = ~full_adder_2_out_0;
  
      always @ (*)
        $display("DigitalLed:NC=%d", not_2_out);
  
      always @ (*)
        $display("DigitalLed:C=%d", full_adder_2_out_0);
  Bi_genreg A(A_out, clk_0, const_0, const_1, A);
  
  assign Splitter_4_cmb = {A_out[6:0],const_4};
  assign TriState_5_out = (Decoder_0_out_6!=0) ? Splitter_4_cmb : 8'b?;
  
  assign Splitter_2_cmb = {Ground_0_out,A_out[7:1]};
  assign TriState_5_out = (Decoder_0_out_5!=0) ? Splitter_2_cmb : 8'b?;
  assign not_0_out = ~A_out;
  assign TriState_5_out = (Decoder_0_out_3!=0) ? not_0_out : 8'b?;
  Decoder8 #(3) Decoder_0(Decoder_0_out_0, Decoder_0_out_1, Decoder_0_out_2, Decoder_0_out_3, Decoder_0_out_4, Decoder_0_out_5, Decoder_0_out_6, , ALU_OP);
  assign const_4 = 1'b0;
  assign const_3 = 1'b1;
  assign const_2 = 1'b0;
  assign const_1 = 1'b1;
  assign const_0 = 1'b0;
  assign Ground_0_out = 1'b0;
endmodule

module gen_reg(OUT, DISP, IN, REG_IN, REG_OUT, CLK);
  output [7:0] OUT, DISP;
  input REG_IN, REG_OUT, CLK;
  input [7:0] IN;
  wire [7:0] DflipFlop_0_Q, TriState_0_out;
  DflipFlop #(8) DflipFlop_0(DflipFlop_0_Q, , CLK, IN, , , REG_IN);
  assign DISP = DflipFlop_0_Q;
  assign TriState_0_out = (REG_OUT!=0) ? DflipFlop_0_Q : 8'b?;
  assign OUT = TriState_0_out;
endmodule

module ins_reg(DISP, OUTPUT, MSB, INPUT, CLOCK, RESET, REG_IN, REG_OUT);
  output [3:0] MSB;
  output [7:0] DISP, OUTPUT;
  input CLOCK, RESET, REG_IN, REG_OUT;
  input [7:0] INPUT;
  wire [7:0] TriState_0_out, DflipFlop_0_Q;
  assign TriState_0_out = (REG_OUT!=0) ? DflipFlop_0_Q : 8'b?;
  assign OUTPUT = TriState_0_out;
  DflipFlop #(8) DflipFlop_0(DflipFlop_0_Q, , CLOCK, INPUT, RESET, , REG_IN);
  
  assign MSB = DflipFlop_0_Q[7:4];
  assign DISP = DflipFlop_0_Q;
endmodule


module SCROLL_DISP(B0_L, B1_L, B2_L, B3_L, Bo_M, B1_M, B2_M, B3_M, CLK, DATA_IN, enable);
  output [3:0] B0_L, B1_L, B2_L, B3_L, Bo_M, B1_M, B2_M, B3_M;
  input CLK, enable;
  input [7:0] DATA_IN;
  wire const_3, const_2, const_1, const_0;
  wire [7:0] B0_out_0, B0_out_1, B3_out_0, B3_out_1, B2_out_0, B2_out_1, B1_out_0, B1_out_1;
  gen_reg B0(B0_out_0, B0_out_1, B1_out_0, enable, const_0, CLK);
  
  assign Bo_M = B0_out_1[7:4];
  assign B0_L = B0_out_1[3:0];
  gen_reg B3(B3_out_0, B3_out_1, DATA_IN, enable, const_3, CLK);
  
  assign B3_M = B3_out_1[7:4];
  assign B3_L = B3_out_1[3:0];
  gen_reg B2(B2_out_0, B2_out_1, B3_out_0, enable, const_2, CLK);
  
  assign B2_M = B2_out_1[7:4];
  assign B2_L = B2_out_1[3:0];
  gen_reg B1(B1_out_0, B1_out_1, B2_out_0, enable, const_1, CLK);
  
  assign B1_M = B1_out_1[7:4];
  assign B1_L = B1_out_1[3:0];
  assign const_3 = 1'b1;
  assign const_2 = 1'b1;
  assign const_1 = 1'b1;
  assign const_0 = 1'b1;
endmodule

module Ring_Counter(T0, T1, T2, T3, T4, RESET, CLK);
  output T0,  T1,  T2,  T3,  T4;
  input RESET, CLK;
  wire DflipFlop_4_Q, DflipFlop_0_Q, DflipFlop_1_Q, DflipFlop_2_Q, DflipFlop_3_Q;
  DflipFlop DflipFlop_4(DflipFlop_4_Q, , CLK, DflipFlop_3_Q, RESET, , );
  assign T4 = DflipFlop_4_Q;
  DflipFlop DflipFlop_0(DflipFlop_0_Q, , CLK, DflipFlop_4_Q, RESET, RESET, );
  assign T0 = DflipFlop_0_Q;
  DflipFlop DflipFlop_1(DflipFlop_1_Q, , CLK, DflipFlop_0_Q, RESET, , );
  assign T1 = DflipFlop_1_Q;
  DflipFlop DflipFlop_2(DflipFlop_2_Q, , CLK, DflipFlop_1_Q, RESET, , );
  assign T2 = DflipFlop_2_Q;
  DflipFlop DflipFlop_3(DflipFlop_3_Q, , CLK, DflipFlop_2_Q, RESET, , );
  assign T3 = DflipFlop_3_Q;
endmodule

module PROGRAM_COUNTER(DISPLAY, OUTPUT, LOAD, INPUT, RESET, INC, OUT, CLK);
  output [7:0] DISPLAY, OUTPUT;
  input LOAD, RESET, INC, OUT, CLK;
  input [7:0] INPUT;
  wire and_2_out, DflipFlop_0_Q, xor_0_out, DflipFlop_1_Q, xor_1_out, and_1_out, DflipFlop_3_Q, xor_2_out, and_0_out, DflipFlop_2_Q, DflipFlop_2_Q_inv, or_0_out;
  wire [3:0] Ground_1_out;
  wire [7:0] Splitter_0_cmb, TriState_0_out, Multiplexer_0_out, Ground_0_out;
  assign and_2_out = INC & CLK;
  DflipFlop DflipFlop_0(DflipFlop_0_Q, , and_2_out, xor_0_out, or_0_out, Multiplexer_0_out[3], );
  assign Splitter_0_cmb = {Ground_1_out[3],Ground_1_out[2],Ground_1_out[1],Ground_1_out[0],DflipFlop_0_Q,DflipFlop_1_Q,DflipFlop_3_Q,DflipFlop_2_Q};
  assign DISPLAY = Splitter_0_cmb;
  assign TriState_0_out = (OUT!=0) ? Splitter_0_cmb : 8'b?;
  assign OUTPUT = TriState_0_out;
  assign xor_0_out = and_1_out ^ DflipFlop_0_Q;
  DflipFlop DflipFlop_1(DflipFlop_1_Q, , and_2_out, xor_1_out, or_0_out, Multiplexer_0_out[2], );
  assign xor_1_out = and_0_out ^ DflipFlop_1_Q;
  assign and_1_out = DflipFlop_1_Q & and_0_out;
  DflipFlop DflipFlop_3(DflipFlop_3_Q, , and_2_out, xor_2_out, or_0_out, Multiplexer_0_out[1], );
  assign xor_2_out = DflipFlop_2_Q ^ DflipFlop_3_Q;
  assign and_0_out = DflipFlop_3_Q & DflipFlop_2_Q;
  DflipFlop DflipFlop_2(DflipFlop_2_Q, DflipFlop_2_Q_inv, and_2_out, DflipFlop_2_Q_inv, or_0_out, Multiplexer_0_out[0], );
  assign or_0_out = LOAD | RESET;
  Multiplexer2 #(8) Multiplexer_0(Multiplexer_0_out, INPUT, Ground_0_out, RESET);
  
  assign Ground_1_out = 4'b0;
  
  assign Ground_0_out = 8'b0;
endmodule


module controller(ALU_O, REG_C_O, REG_C_IN, REG_B_O, REG_B_IN, REG_A_O, REG_A_IN, MAR_IN, IR_O, IR_IN, MEM_O, MEM_I, PC_LD, PC_O, PC_INC, HALT, CTRL_WORD, ZF, INS, reset, CLK);
  output ALU_O,  REG_C_O,  REG_C_IN,  REG_B_O,  REG_B_IN,  REG_A_O,  REG_A_IN,  MAR_IN,  IR_O,  IR_IN,  MEM_O,  MEM_I,  PC_LD,  PC_O,  PC_INC,  HALT;
  output [15:0] CTRL_WORD;
  input ZF, reset, CLK;
  input [3:0] INS;
  wire not_0_out, Ring_Counter_0_out_0, Ring_Counter_0_out_1, Ring_Counter_0_out_2, Ring_Counter_0_out_3, Ring_Counter_0_out_4, PriorityEncoder_0_out_0, PriorityEncoder_0_out_1, PriorityEncoder_0_out_2, Ground_0_out;
  wire [7:0] Splitter_0_cmb;
  wire [15:0] EEPROM_0_DATA_OUT;
  assign not_0_out = ~CLK;
  Ring_Counter Ring_Counter_0(Ring_Counter_0_out_0, Ring_Counter_0_out_1, Ring_Counter_0_out_2, Ring_Counter_0_out_3, Ring_Counter_0_out_4, reset, not_0_out);
  PriorityEncoder8 #(3) PriorityEncoder_0(PriorityEncoder_0_out_0, PriorityEncoder_0_out_1, PriorityEncoder_0_out_2, , Ring_Counter_0_out_0, Ring_Counter_0_out_1, Ring_Counter_0_out_2, Ring_Counter_0_out_3, Ring_Counter_0_out_4, Ground_0_out, Ground_0_out, Ground_0_out);
  assign Splitter_0_cmb = {ZF,INS,PriorityEncoder_0_out_2,PriorityEncoder_0_out_1,PriorityEncoder_0_out_0};
  EEPROM #(16) EEPROM_0(EEPROM_0_DATA_OUT, Splitter_0_cmb, , , , );
  assign CTRL_WORD = EEPROM_0_DATA_OUT;
  
  assign HALT = EEPROM_0_DATA_OUT[15];
  assign PC_INC = EEPROM_0_DATA_OUT[14];
  assign PC_O = EEPROM_0_DATA_OUT[13];
  assign PC_LD = EEPROM_0_DATA_OUT[12];
  assign MEM_I = EEPROM_0_DATA_OUT[11];
  assign MEM_O = EEPROM_0_DATA_OUT[10];
  assign IR_IN = EEPROM_0_DATA_OUT[9];
  assign IR_O = EEPROM_0_DATA_OUT[8];
  assign MAR_IN = EEPROM_0_DATA_OUT[7];
  assign REG_A_IN = EEPROM_0_DATA_OUT[6];
  assign REG_A_O = EEPROM_0_DATA_OUT[5];
  assign REG_B_IN = EEPROM_0_DATA_OUT[4];
  assign REG_B_O = EEPROM_0_DATA_OUT[3];
  assign REG_C_IN = EEPROM_0_DATA_OUT[2];
  assign REG_C_O = EEPROM_0_DATA_OUT[1];
  assign ALU_O = EEPROM_0_DATA_OUT[0];
  
  
      always @ (*)
        $display("HexDisplay:HexDisplay_0=%d", EEPROM_0_DATA_OUT[15:12]);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_1=%d", EEPROM_0_DATA_OUT[11:8]);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_2=%d", EEPROM_0_DATA_OUT[7:4]);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_3=%d", EEPROM_0_DATA_OUT[3:0]);
  assign Ground_0_out = 1'b0;
endmodule

module status_reg(OUT, Z, INPUT, CLK, REG_IN);
  output Z;
  output [3:0] OUT;
  input CLK, REG_IN;
  input [3:0] INPUT;
  wire [3:0] DflipFlop_0_Q;
  DflipFlop #(4) DflipFlop_0(DflipFlop_0_Q, , CLK, INPUT, , , REG_IN);
  
  assign Z = DflipFlop_0_Q[2];
  assign OUT = DflipFlop_0_Q;
endmodule

module instruction_decoder(OUT, ALU_OP, IN, CTRL, REG_IN);
  output [2:0] ALU_OP;
  output [7:0] OUT;
  input REG_IN;
  input [3:0] CTRL;
  input [7:0] IN;
  wire Decoder_0_out_0, Decoder_0_out_1, Decoder_0_out_2, Decoder_0_out_3, or_0_out;
  wire [2:0] Splitter_2_cmb;
  wire [3:0] Multiplexer_0_out, const_0;
  wire [7:0] TriState_0_out, Splitter_1_cmb;
  assign TriState_0_out = (REG_IN!=0) ? Splitter_1_cmb : 8'b?;
  assign OUT = TriState_0_out;
  Decoder16 #(4) Decoder_0(, , , , Decoder_0_out_0, Decoder_0_out_1, , , , , , , Decoder_0_out_2, Decoder_0_out_3, , , CTRL);
  assign or_0_out = Decoder_0_out_0 | Decoder_0_out_2 | Decoder_0_out_3;
  assign Splitter_2_cmb = {or_0_out,Decoder_0_out_2,Decoder_0_out_3};
  assign ALU_OP = Splitter_2_cmb;
  Multiplexer2 #(4) Multiplexer_0(Multiplexer_0_out, IN[7:4], const_0, Decoder_0_out_1);
  assign Splitter_1_cmb = {Multiplexer_0_out,IN[3:0]};
  
  assign const_0 = 4'b0000;
endmodule














module BUS_OUTLAY(out_0, out_1, out_2, out_3, out_4, out_5, out_6, out_7, out_8, clk_0, inp_0);
  output [2:0] out_8;
  output [3:0] out_7;
  output [7:0] out_0, out_1, out_2, out_3, out_4, out_5, out_6;
  input inp_0, clk_0;
  wire controller_8_out_0, controller_8_out_1, controller_8_out_2, controller_8_out_3, controller_8_out_4, controller_8_out_5, controller_8_out_6, controller_8_out_7, controller_8_out_8, controller_8_out_9, controller_8_out_10, controller_8_out_11, controller_8_out_12, controller_8_out_13, controller_8_out_14, controller_8_out_15, status_reg_9_out_1;
  wire [2:0] instruction_decoder_10_out_1;
  wire [3:0] gajendraAlu_2_out_2, status_reg_9_out_0, SCROLL_DISP_6_out_0, SCROLL_DISP_6_out_1, SCROLL_DISP_6_out_2, SCROLL_DISP_6_out_3, SCROLL_DISP_6_out_4, SCROLL_DISP_6_out_5, SCROLL_DISP_6_out_6, SCROLL_DISP_6_out_7, ins_reg_0_out_2;
  wire [7:0] PROGRAM_COUNTER_7_out_0, PROGRAM_COUNTER_7_out_1, EEPROM_0_DATA_OUT, Multiplexer_0_out, REG_B_out, gajendraAlu_2_out_1, C_out, gen_reg_1_out_0, gen_reg_1_out_1, ins_reg_0_out_0, ins_reg_0_out_1, REG_A_out, const_0;
  wire [15:0] controller_8_out_16;
  controller controller_8(controller_8_out_0, controller_8_out_1, controller_8_out_2, controller_8_out_3, controller_8_out_4, controller_8_out_5, controller_8_out_6, controller_8_out_7, controller_8_out_8, controller_8_out_9, controller_8_out_10, controller_8_out_11, controller_8_out_12, controller_8_out_13, controller_8_out_14, controller_8_out_15, controller_8_out_16, status_reg_9_out_1, ins_reg_0_out_2, inp_0, clk_0);
  
  
      always @ (*)
        $display("HexDisplay:HexDisplay_8=%d", controller_8_out_16[15:12]);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_9=%d", controller_8_out_16[11:8]);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_10=%d", controller_8_out_16[7:4]);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_11=%d", controller_8_out_16[3:0]);
  PROGRAM_COUNTER PROGRAM_COUNTER_7(PROGRAM_COUNTER_7_out_0, PROGRAM_COUNTER_7_out_1, controller_8_out_12, PROGRAM_COUNTER_7_out_1, inp_0, controller_8_out_14, controller_8_out_13, clk_0);
  EEPROM #(8) EEPROM_0(EEPROM_0_DATA_OUT, gen_reg_1_out_1[3:0], PROGRAM_COUNTER_7_out_1, controller_8_out_11, , );
  Multiplexer2 #(8) Multiplexer_0(Multiplexer_0_out, const_0, EEPROM_0_DATA_OUT, controller_8_out_10);
  assign PROGRAM_COUNTER_7_out_1 = (controller_8_out_10!=0) ? Multiplexer_0_out : 8'b?;
  assign out_5 = PROGRAM_COUNTER_7_out_1;
  Bi_genreg REG_B(REG_B_out, clk_0, controller_8_out_3, controller_8_out_4, PROGRAM_COUNTER_7_out_1);
  assign out_4 = REG_B_out;
  gajendraAlu gajendraAlu_2(PROGRAM_COUNTER_7_out_1, gajendraAlu_2_out_1, gajendraAlu_2_out_2, REG_A_out, REG_B_out, instruction_decoder_10_out_1, controller_8_out_0);
  status_reg status_reg_9(status_reg_9_out_0, status_reg_9_out_1, gajendraAlu_2_out_2, clk_0, controller_8_out_0);
  assign out_3 = gajendraAlu_2_out_1;
  Bi_genreg C(C_out, clk_0, controller_8_out_1, controller_8_out_2, PROGRAM_COUNTER_7_out_1);
  
  
      always @ (*)
        $display("HexDisplay:HexDisplay_12=%d", C_out[7:4]);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_13=%d", C_out[3:0]);
  SCROLL_DISP SCROLL_DISP_6(SCROLL_DISP_6_out_0, SCROLL_DISP_6_out_1, SCROLL_DISP_6_out_2, SCROLL_DISP_6_out_3, SCROLL_DISP_6_out_4, SCROLL_DISP_6_out_5, SCROLL_DISP_6_out_6, SCROLL_DISP_6_out_7, , C_out, controller_8_out_4);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_6=%d", SCROLL_DISP_6_out_7);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_4=%d", SCROLL_DISP_6_out_6);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_2=%d", SCROLL_DISP_6_out_5);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_0=%d", SCROLL_DISP_6_out_4);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_7=%d", SCROLL_DISP_6_out_3);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_5=%d", SCROLL_DISP_6_out_2);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_3=%d", SCROLL_DISP_6_out_1);
  
      always @ (*)
        $display("HexDisplay:HexDisplay_1=%d", SCROLL_DISP_6_out_0);
  gen_reg gen_reg_1(gen_reg_1_out_0, gen_reg_1_out_1, PROGRAM_COUNTER_7_out_1, controller_8_out_7, , clk_0);
  assign out_6 = gen_reg_1_out_1;
  
  ins_reg ins_reg_0(ins_reg_0_out_0, ins_reg_0_out_1, ins_reg_0_out_2, PROGRAM_COUNTER_7_out_1, clk_0, inp_0, controller_8_out_9, controller_8_out_8);
  instruction_decoder instruction_decoder_10(PROGRAM_COUNTER_7_out_1, instruction_decoder_10_out_1, ins_reg_0_out_1, ins_reg_0_out_2, controller_8_out_8);
  assign out_8 = instruction_decoder_10_out_1;
  assign out_7 = ins_reg_0_out_2;
  assign out_0 = ins_reg_0_out_0;
  Bi_genreg REG_A(REG_A_out, clk_0, controller_8_out_5, controller_8_out_6, PROGRAM_COUNTER_7_out_1);
  assign out_1 = REG_A_out;
  assign out_2 = PROGRAM_COUNTER_7_out_0;
  assign const_0 = 8'b00000000;
endmodule


module MAR(MAR_ADD, REG_IN, CLK, inp_2);
  output [3:0] MAR_ADD;
  input REG_IN, CLK;
  input [7:0] inp_2;
  wire [7:0] gen_reg_0_out_0, gen_reg_0_out_1;
  gen_reg gen_reg_0(gen_reg_0_out_0, gen_reg_0_out_1, inp_2, REG_IN, , CLK);
  
  assign MAR_ADD = gen_reg_0_out_1[3:0];
endmodule

module DflipFlop(q, q_inv, clk, d, a_rst, pre, en);
    parameter WIDTH = 1;
    output reg [WIDTH-1:0] q, q_inv;
    input clk, a_rst, pre, en;
    input [WIDTH-1:0] d;

    always @ (posedge clk or posedge a_rst)
    if (a_rst) begin
        q <= 'b0;
        q_inv <= 'b1;
    end else if (en == 0) ;
    else begin
        q <= d;
        q_inv <= ~d;
    end
endmodule
    
module Decoder8(out0, out1, out2, out3, out4, out5, out6, out7, sel);
  output reg out0, out1, out2, out3, out4, out5, out6, out7;
  input [2:0] sel;
  
  always @ (*) begin
    out0 = 0;
    out1 = 0;
    out2 = 0;
    out3 = 0;
    out4 = 0;
    out5 = 0;
    out6 = 0;
    out7 = 0;
    case (sel)
      0 : out0 = 1;
      1 : out1 = 1;
      2 : out2 = 1;
      3 : out3 = 1;
      4 : out4 = 1;
      5 : out5 = 1;
      6 : out6 = 1;
      7 : out7 = 1;
    endcase
  end
endmodule

module Decoder16(out0, out1, out2, out3, out4, out5, out6, out7, out8, out9, out10, out11, out12, out13, out14, out15, sel);
  output reg out0, out1, out2, out3, out4, out5, out6, out7, out8, out9, out10, out11, out12, out13, out14, out15;
  input [3:0] sel;
  
  always @ (*) begin
    out0 = 0;
    out1 = 0;
    out2 = 0;
    out3 = 0;
    out4 = 0;
    out5 = 0;
    out6 = 0;
    out7 = 0;
    out8 = 0;
    out9 = 0;
    out10 = 0;
    out11 = 0;
    out12 = 0;
    out13 = 0;
    out14 = 0;
    out15 = 0;
    case (sel)
      0 : out0 = 1;
      1 : out1 = 1;
      2 : out2 = 1;
      3 : out3 = 1;
      4 : out4 = 1;
      5 : out5 = 1;
      6 : out6 = 1;
      7 : out7 = 1;
      8 : out8 = 1;
      9 : out9 = 1;
      10 : out10 = 1;
      11 : out11 = 1;
      12 : out12 = 1;
      13 : out13 = 1;
      14 : out14 = 1;
      15 : out15 = 1;
    endcase
  end
endmodule

module Multiplexer2(out, in0, in1, sel);
  parameter WIDTH = 1;
  output reg [WIDTH-1:0] out;
  input [WIDTH-1:0] in0, in1;
  input [0:0] sel;
  
  always @ (*)
    case (sel)
      0 : out = in0;
      1 : out = in1;
    endcase
endmodule


module PriorityEncoder8(sel, ze, in0, in1, in2, in3, in4, in5, in6, in7);
  output reg [2:0] sel;
  output reg ze;
  input in0, in1, in2, in3, in4, in5, in6, in7;

  always @ (*) begin
    sel = 0;
    ze = 0;
    if (in7)
      sel = 7;
    else
      ze = 1;
  end
endmodule

    module EEPROM(dout, addr, din, we, dmp, rst);
        parameter WIDTH = 8;
        parameter ADDR = 10;
        output [WIDTH-1:0] dout;
        input [ADDR-1:0] addr;
        input [WIDTH-1:0] din;
        input we;
        input dmp;
        input rst;
        reg [WIDTH-1:0] mem[2**ADDR-1:0];
        integer j;
    
        assign dout = mem[addr];
    
        always @ (*) begin
        if (!rst)
            for (j=0; j < 2**ADDR-1; j=j+1) begin
                mem[j] = 0;
            end
        if (!we)
            mem[addr] = din;
        dout = mem[addr];
        end
    endmodule
    